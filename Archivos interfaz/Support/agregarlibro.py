#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Nov 16, 2024 11:04:35 AM EST  platform: Windows NT
import sys
import tkinter as tk
from tkinter import ttk
from tkinter.constants import *
import os
import json
import uuid
import subprocess

_location = os.path.dirname(__file__)

import agregarlibro_support

_bgcolor = '#d9d9d9'
_fgcolor = '#000000'
_tabfg1 = 'black' 
_tabfg2 = 'white' 
_bgmode = 'light' 
_tabbg1 = '#d9d9d9' 
_tabbg2 = 'gray40' 

_style_code_ran = 0
def _style_code():
    global _style_code_ran
    if _style_code_ran: return        
    try: 
        agregarlibro_support.root.tk.call('source',
                    os.path.join(_location, 'themes', 'default.tcl'))
    except: 
        pass
    style = ttk.Style()
    style.theme_use('default')
    style.configure('.', font = "TkDefaultFont")
    if sys.platform == "win32":
       style.theme_use('winnative')    
    _style_code_ran = 1

class AutocompleteEntry(tk.Entry):
    def __init__(self, master, completion_list, *args, **kwargs):
        super().__init__(master, *args, **kwargs)

        self.completion_list = sorted(completion_list, key=str.lower)
        self.var = self["textvariable"] = tk.StringVar()
        self.var.trace('w', self.changed)

        self.bind("<Right>", self.selection)
        self.bind("<Down>", self.move_down)
        # Comentado para evitar cierre inmediato del Listbox
        # self.bind("<FocusOut>", lambda event: self.close_listbox())

        self.listbox = None
        self.master = master
        self.root = master.winfo_toplevel()
        # Comentado para evitar interferencias globales
        # self.root.bind("<Button-1>", self.click_outside)

    def changed(self, name, index, mode):
        print("Cambio detectado en el campo de entrada.")
        if self.var.get() == '':
            self.close_listbox()
        else:
            words = self.completion_list
            pattern = self.var.get().lower()
            matches = [w for w in words if pattern in w.lower()]
            print(f"Coincidencias encontradas: {matches}")
            if matches:
                if not self.listbox:
                    self.create_listbox()
                self.listbox.delete(0, tk.END)
                for w in matches:
                    self.listbox.insert(tk.END, w)
            else:
                self.close_listbox()

    def create_listbox(self):
        print("Creando Listbox para sugerencias.")
        self.listbox = tk.Listbox(self.master, font=self['font'], takefocus=False)
        self.listbox.bind("<<ListboxSelect>>", self.selection)
        self.listbox.bind("<Right>", self.selection)
        self.listbox.bind("<Return>", self.selection)
        self.listbox.bind("<FocusOut>", self.on_listbox_focus_out)

        # Asegurarse de que la geometría esté actualizada
        self.update_idletasks()

        # Posicionar el listbox directamente debajo del entry
        x = self.winfo_x()
        y = self.winfo_y() + self.winfo_height()
        width = self.winfo_width()
        self.listbox.place(in_=self.master, x=x, y=y, width=width)
        self.listbox.lift()  # Traer el listbox al frente
        print(f"Listbox posicionado en x={x}, y={y}, width={width}.")

    def selection(self, event):
        if self.listbox:
            if self.listbox.curselection():
                index = self.listbox.curselection()[0]
                data = self.listbox.get(index)
                self.var.set(data)
                print(f"Selección realizada: {data}")
                self.close_listbox()
                self.icursor(tk.END)

    def move_down(self, event):
        if self.listbox:
            self.listbox.focus_set()
            self.listbox.select_set(0)
            print("Navegando hacia abajo en la lista de sugerencias.")

    def close_listbox(self):
        if self.listbox:
            print("Cerrando Listbox de sugerencias.")
            self.listbox.destroy()
            self.listbox = None

    def on_listbox_focus_out(self, event):
        print("Listbox perdió el foco. Cerrando.")
        self.close_listbox()

    # Eliminado el método click_outside para evitar conflictos
    # def click_outside(self, event):
    #     if self.listbox:
    #         # Verificar si el clic fue dentro del entry o el listbox
    #         if event.widget != self and event.widget != self.listbox:
    #             self.close_listbox()

class Toplevel1:
    def __init__(self, top=None):
        '''Esta clase configura y popula la ventana principal.'''
        top.geometry("600x450+468+138")
        top.minsize(120, 1)
        top.maxsize(1540, 845)
        top.resizable(1, 1)
        top.title("Agregar Libro")
        top.configure(background="#98e4fe")
        top.configure(highlightbackground="#d9d9d9")
        top.configure(highlightcolor="#000000")

        self.top = top
        self.base_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../base_de_datos'))

        # Cargar datos desde los archivos JSON
        self.autor_data = self.cargar_datos("autores.json")
        self.editorial_data = self.cargar_datos("editoriales.json")
        self.genero_data = self.cargar_datos("generos.json")

        # Inicializar listas
        self.genero_lista = []
        self.autor_lista = [autor["nombre"] for autor in self.autor_data]
        self.editorial_lista = [editorial["nombre"] for editorial in self.editorial_data]
        self.actualizar_genero_lista()

        # UI Principal
        self.Frame1 = tk.Frame(self.top)
        self.Frame1.place(relx=0.167, rely=0.111, relheight=0.744, relwidth=0.675)
        self.Frame1.configure(relief='groove', borderwidth="2", background="#9b0a64")

        # Etiqueta principal
        self.Label1 = tk.Label(self.Frame1, text='''Completa la información''', font="-family {Segoe UI} -size 9",
                               background="#9b0a64", foreground="#ffffff")
        self.Label1.place(relx=0.321, rely=0.06, height=21, width=146)

        # Campos de texto y comboboxes
        self.crear_label(self.Frame1, "Título:", 0.209)
        self.titulo_entry = self.crear_entry(self.Frame1, 0.209)

        self.crear_label(self.Frame1, "Autor:", 0.328)
        self.autor_combo = self.crear_autocomplete_entry(
            self.Frame1, 0.328, self.autor_lista)

        self.crear_label(self.Frame1, "Género:", 0.448)
        self.genero_combo = self.crear_autocomplete_entry(
            self.Frame1, 0.448, self.genero_lista)

        self.crear_label(self.Frame1, "Editorial:", 0.567)
        self.editorial_combo = self.crear_autocomplete_entry(
            self.Frame1, 0.567, self.editorial_lista)

        self.crear_label(self.Frame1, "Año:", 0.687)
        self.anio_entry = self.crear_entry(self.Frame1, 0.687)

        self.crear_label(self.Frame1, "ISBN:", 0.806)
        self.isbn_entry = self.crear_entry(self.Frame1, 0.806)

        # Botones
        self.btnRegresar = tk.Button(self.Frame1, text="Regresar", background="#fecb01", command=self.regresar)
        self.btnRegresar.place(relx=0.049, rely=0.896, height=26, width=57)

        self.btnAgregar = tk.Button(self.Frame1, text="Agregar", background="#ff0080", foreground="#ffffff",
                                    command=self.agregar)
        self.btnAgregar.place(relx=0.79, rely=0.896, height=26, width=57)

    def cargar_datos(self, archivo):
        """Carga datos desde un archivo JSON en la carpeta base_de_datos."""
        ruta = os.path.join(self.base_path, archivo)
        if not os.path.exists(ruta):
            print(f"Archivo no encontrado: {ruta}")
            raise FileNotFoundError(f"El archivo {archivo} no se encontró en la ruta: {ruta}")
        with open(ruta, 'r', encoding='utf-8') as file:
            datos = json.load(file)
            print(f"Datos cargados desde {archivo}: {datos}")  # Depuración
            return datos

    def actualizar_genero_lista(self):
        """Actualiza la lista de géneros para incluir solo los géneros hoja sin prefijos de guiones."""
        generos = self.genero_data  # Ya cargado en __init__

        # Función auxiliar para determinar si un género es hoja
        def es_hoja(genero_id, todos_generos):
            return not any(g for g in todos_generos if g.get("generoPadreId") == genero_id)

        # Filtrar solo aquellos géneros que no tienen hijos
        generos_hoja = [g for g in generos if es_hoja(g["id"], generos)]
        print(f"Géneros hoja identificados: {generos_hoja}")  # Depuración

        # Lista final de nombres de géneros sin guiones ni espacios adicionales
        self.genero_lista = [g["nombre"].strip('- ').strip() for g in generos_hoja]
        print(f"Lista final de géneros para el usuario: {self.genero_lista}")  # Depuración

    def crear_label(self, parent, texto, rel_y):
        """Crea un label en una posición relativa."""
        label = tk.Label(parent, text=texto, font="-family {Segoe UI} -size 9",
                        background="#9b0a64", foreground="#ffffff")
        label.place(relx=0.198, rely=rel_y, height=21, width=64)

    def crear_entry(self, parent, rel_y):
        """Crea un campo de texto en una posición relativa."""
        entry = ttk.Entry(parent, font="-family {Segoe UI} -size 9")
        entry.place(relx=0.37, rely=rel_y, relheight=0.057, relwidth=0.331)
        return entry

    def crear_autocomplete_entry(self, parent, rel_y, values):
        """Crea un AutocompleteEntry interactivo."""
        entry = AutocompleteEntry(parent, values, font="-family {Segoe UI} -size 9")
        entry.place(relx=0.37, rely=rel_y, relheight=0.057, relwidth=0.338)
        return entry

    def regresar(self):
        """Lógica para el botón Regresar."""
        print("Botón 'Regresar' presionado.")
        # Cerrar la ventana actual
        self.top.destroy()
        # Importar y llamar al método principal de navegacion.py
        import navegacion
        navegacion.start_up()


    def agregar(self):
        """Lógica para el botón Agregar."""
        # Obtener los valores de los campos
        titulo = self.titulo_entry.get().strip()
        autor = self.autor_combo.get().strip()
        genero = self.genero_combo.get().strip().replace('-', '').strip()
        editorial = self.editorial_combo.get().strip()
        anio = self.anio_entry.get().strip()
        isbn = self.isbn_entry.get().strip()
        print(f"Título: {titulo}, Autor: {autor}, Género: {genero}, Editorial: {editorial}, Año: {anio}, ISBN: {isbn}")

        # Validar los campos
        if not titulo or not autor or not genero or not editorial or not anio or not isbn:
            print("Por favor, completa todos los campos.")
            return

        # Inicializar variables para IDs
        autor_id = None
        genero_id = None
        editorial_id = None

        try:
            # Buscar el ID del autor
            autores_path = os.path.join(self.base_path, "autores.json")
            with open(autores_path, 'r', encoding='utf-8') as f:
                autores = json.load(f)
            print(f"Autores cargados: {[a['nombre'] for a in autores]}")  # Depuración
            autor_lower = autor.lower()
            autor_id = next((a["id"] for a in autores if a["nombre"].lower() == autor_lower), None)
            print(f"Autor ID encontrado: {autor_id}")  # Depuración

            # Buscar el ID del género
            generos_path = os.path.join(self.base_path, "generos.json")
            with open(generos_path, 'r', encoding='utf-8') as f:
                generos = json.load(f)
            print(f"Géneros cargados: {[g['nombre'] for g in generos]}")  # Depuración
            genero_lower = genero.lower()
            genero_id = next((g["id"] for g in generos if g["nombre"].strip('- ').lower() == genero_lower), None)
            print(f"Género ID encontrado: {genero_id}")  # Depuración

            # Buscar el ID de la editorial
            editoriales_path = os.path.join(self.base_path, "editoriales.json")
            with open(editoriales_path, 'r', encoding='utf-8') as f:
                editoriales = json.load(f)
            print(f"Editoriales cargadas: {[e['nombre'] for e in editoriales]}")  # Depuración
            editorial_lower = editorial.lower()
            editorial_id = next((e["id"] for e in editoriales if e["nombre"].lower() == editorial_lower), None)
            print(f"Editorial ID encontrado: {editorial_id}")  # Depuración

            # Verificar que todos los IDs fueron encontrados
            if not all([autor_id, genero_id, editorial_id]):
                print("Error: No se encontraron uno o más IDs requeridos.")
                return

        except FileNotFoundError as e:
            print(f"Archivo no encontrado: {e}")
            return
        except json.JSONDecodeError as e:
            print(f"Error al decodificar JSON: {e}")
            return
        except StopIteration:
            print("Error: No se encontró uno de los valores requeridos.")
            return
        except Exception as e:
            print(f"Error inesperado: {e}")
            return

        # Generar UUID para el libro
        libro_id = str(uuid.uuid4())

        # Validar que el año sea un número entero
        try:
            anio_int = int(anio)
        except ValueError:
            print("El año debe ser un número entero.")
            return

        # Crear el diccionario del libro con los IDs
        libro = {
            "id": libro_id,
            "titulo": titulo,
            "autorId": autor_id,
            "generoId": genero_id,
            "anio_publicacion": anio_int,
            "editorialId": editorial_id,
            "isbn": isbn
        }
        print(f"Libro a agregar: {libro}")  # Depuración

        # Guardar en books.json
        try:
            books_path = os.path.join(self.base_path, "books.json")
            if not os.path.exists(books_path):
                with open(books_path, 'w', encoding='utf-8') as f:
                    json.dump([], f, ensure_ascii=False, indent=4)
                print("Creado archivo books.json vacío.")  # Depuración

            with open(books_path, 'r+', encoding='utf-8') as f:
                try:
                    books = json.load(f)
                except json.JSONDecodeError:
                    books = []
                books.append(libro)
                f.seek(0)
                json.dump(books, f, ensure_ascii=False, indent=4)
                f.truncate()  # Asegurar que se eliminen datos sobrantes
            print(f"Libro agregado a {books_path}")  # Depuración

        except Exception as e:
            print(f"Error al guardar el libro: {e}")
            return

        # Ejecutar los scripts de persistencia
        try:
            # Definir la ruta absoluta a la carpeta de scripts
            scripts_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', 'arboles_persistencia'))
            scripts = ['guardar_bal.py', 'guardar_nary.py', 'guardar_bin.py']
            for script in scripts:
                script_path = os.path.join(scripts_dir, script)
                if not os.path.exists(script_path):
                    print(f"Script '{script}' no encontrado en '{scripts_dir}'.")
                    continue
                # Ejecutar el script
                print(f"Ejecutando script: {script_path}")  # Depuración
                subprocess.run(['python', script_path], check=True)
            print("Scripts de persistencia ejecutados correctamente.")  # Depuración
        except subprocess.CalledProcessError as e:
            print(f"Error al ejecutar el script {script}: {e}")
            return
        except Exception as e:
            print(f"Error al ejecutar los scripts: {e}")
            return

        print("Libro agregado exitosamente.")

        # Limpiar los campos después de agregar
        self.titulo_entry.delete(0, tk.END)
        self.autor_combo.var.set('')
        self.genero_combo.var.set('')
        self.editorial_combo.var.set('')
        self.anio_entry.delete(0, tk.END)
        self.isbn_entry.delete(0, tk.END)

# Para ejecutar la ventana de prueba
if __name__ == "__main__":
    root = tk.Tk()
    _style_code()
    app = Toplevel1(top=root)
    root.mainloop()
