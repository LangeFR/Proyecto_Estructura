#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Nov 16, 2024 11:04:35 AM EST  platform: Windows NT
import sys
import tkinter as tk
from tkinter import ttk
from tkinter.constants import *
import os
import json
import uuid
import subprocess
from tkinter import messagebox  # Importar el módulo de messagebox
import re  # Importar el módulo de expresiones regulares
from datetime import datetime
from datetime import datetime



_location = os.path.dirname(__file__)

import agregarlibro_support

_bgcolor = '#d9d9d9'
_fgcolor = '#000000'
_tabfg1 = 'black' 
_tabfg2 = 'white' 
_bgmode = 'light' 
_tabbg1 = '#d9d9d9' 
_tabbg2 = 'gray40' 

_style_code_ran = 0
def _style_code():
    global _style_code_ran
    if _style_code_ran: return        
    try: 
        agregarlibro_support.root.tk.call('source',
                    os.path.join(_location, 'themes', 'default.tcl'))
    except: 
        pass
    style = ttk.Style()
    style.theme_use('default')
    style.configure('.', font = "TkDefaultFont")
    if sys.platform == "win32":
       style.theme_use('winnative')    
    _style_code_ran = 1

class AutocompleteEntry(tk.Entry):
    def __init__(self, master, completion_list, *args, **kwargs):
        super().__init__(master, *args, **kwargs)

        self.completion_list = sorted(completion_list, key=str.lower)
        self.var = self["textvariable"] = tk.StringVar()
        self.var.trace('w', self.changed)

        self.bind("<Right>", self.selection)
        self.bind("<Down>", self.move_down)
        # Comentado para evitar cierre inmediato del Listbox
        # self.bind("<FocusOut>", lambda event: self.close_listbox())

        self.listbox = None
        self.master = master
        self.root = master.winfo_toplevel()
        # Comentado para evitar interferencias globales
        # self.root.bind("<Button-1>", self.click_outside)

    def changed(self, name, index, mode):
        print("Cambio detectado en el campo de entrada.")
        if self.var.get() == '':
            self.close_listbox()
        else:
            words = self.completion_list
            pattern = self.var.get().lower()
            matches = [w for w in words if pattern in w.lower()]
            print(f"Coincidencias encontradas: {matches}")
            if matches:
                if not self.listbox:
                    self.create_listbox()
                self.listbox.delete(0, tk.END)
                for w in matches:
                    self.listbox.insert(tk.END, w)
            else:
                self.close_listbox()

    def create_listbox(self):
        print("Creando Listbox para sugerencias.")
        self.listbox = tk.Listbox(self.master, font=self['font'], takefocus=False)
        self.listbox.bind("<<ListboxSelect>>", self.selection)
        self.listbox.bind("<Right>", self.selection)
        self.listbox.bind("<Return>", self.selection)
        self.listbox.bind("<FocusOut>", self.on_listbox_focus_out)

        # Asegurarse de que la geometría esté actualizada
        self.update_idletasks()

        # Posicionar el listbox directamente debajo del entry
        x = self.winfo_x()
        y = self.winfo_y() + self.winfo_height()
        width = self.winfo_width()
        self.listbox.place(in_=self.master, x=x, y=y, width=width)
        self.listbox.lift()  # Traer el listbox al frente
        print(f"Listbox posicionado en x={x}, y={y}, width={width}.")

    def selection(self, event):
        if self.listbox:
            if self.listbox.curselection():
                index = self.listbox.curselection()[0]
                data = self.listbox.get(index)
                self.var.set(data)
                print(f"Selección realizada: {data}")
                self.close_listbox()
                self.icursor(tk.END)

    def move_down(self, event):
        if self.listbox:
            self.listbox.focus_set()
            self.listbox.select_set(0)
            print("Navegando hacia abajo en la lista de sugerencias.")

    def close_listbox(self):
        if self.listbox:
            print("Cerrando Listbox de sugerencias.")
            self.listbox.destroy()
            self.listbox = None

    def on_listbox_focus_out(self, event):
        print("Listbox perdió el foco. Cerrando.")
        self.close_listbox()

    # Eliminado el método click_outside para evitar conflictos
    # def click_outside(self, event):
    #     if self.listbox:
    #         # Verificar si el clic fue dentro del entry o el listbox
    #         if event.widget != self and event.widget != self.listbox:
    #             self.close_listbox()

class Toplevel1:

    def __init__(self, top=None):
        '''Esta clase configura y popula la ventana principal.'''
        top.geometry("600x500")
        top.resizable(0, 0)
        top.title("Agregar Libro")
        top.configure(background="#98e4fe")  # Fondo original

        self.top = top

        # Frame principal
        self.Frame1 = tk.Frame(self.top)
        self.Frame1.place(relx=0.1, rely=0.1, relheight=0.8, relwidth=0.8)
        self.Frame1.configure(relief='groove', borderwidth="2", background="#9b0a64")
        self.Frame1.configure(highlightbackground="#d9d9d9", highlightcolor="#000000")

        # Etiqueta principal
        self.Label1 = tk.Label(
            self.Frame1,
            text='''Agregar un nuevo libro''',
            font="-family {Segoe UI} -size 14 -weight bold",
            background="#9b0a64",
            foreground="#ffffff"
        )
        self.Label1.place(relx=0.2, rely=0.05, relwidth=0.6, height=30)

        # Campos de texto
        self.crear_label(self.Frame1, "Título:", 0.2)
        self.titulo_entry = self.crear_entry(self.Frame1, 0.2)

        self.crear_label(self.Frame1, "Autor:", 0.3)
        self.autor_entry = self.crear_entry(self.Frame1, 0.3)

        self.crear_label(self.Frame1, "Género:", 0.4)
        self.genero_entry = self.crear_entry(self.Frame1, 0.4)

        self.crear_label(self.Frame1, "Editorial:", 0.5)
        self.editorial_entry = self.crear_entry(self.Frame1, 0.5)

        self.crear_label(self.Frame1, "Año:", 0.6)
        self.anio_entry = self.crear_entry(self.Frame1, 0.6)

        self.crear_label(self.Frame1, "ISBN:", 0.7)
        self.isbn_entry = self.crear_entry(self.Frame1, 0.7)

        # Botones centrados
        self.btnAgregar = tk.Button(self.Frame1, text="Agregar", font="-family {Segoe UI} -size 10 -weight bold",
                                    background="#ffcc00", command=self.agregar)
        self.btnAgregar.place(relx=0.25, rely=0.85, height=35, width=100)

        self.btnRegresar = tk.Button(self.Frame1, text="Regresar", font="-family {Segoe UI} -size 10 -weight bold",
                                     background="#f97db1", command=self.regresar)
        self.btnRegresar.place(relx=0.55, rely=0.85, height=35, width=100)



    def cargar_datos(self, archivo):
        """Carga datos desde un archivo JSON en la carpeta base_de_datos."""
        ruta = os.path.join(self.base_path, archivo)
        if not os.path.exists(ruta):
            print(f"Archivo no encontrado: {ruta}")
            raise FileNotFoundError(f"El archivo {archivo} no se encontró en la ruta: {ruta}")
        with open(ruta, 'r', encoding='utf-8') as file:
            datos = json.load(file)
            print(f"Datos cargados desde {archivo}: {datos}")  # Depuración
            return datos

    def actualizar_genero_lista(self):
        """Actualiza la lista de géneros para incluir solo los géneros hoja sin prefijos de guiones."""
        generos = self.genero_data  # Ya cargado en __init__

        # Función auxiliar para determinar si un género es hoja
        def es_hoja(genero_id, todos_generos):
            return not any(g for g in todos_generos if g.get("generoPadreId") == genero_id)

        # Filtrar solo aquellos géneros que no tienen hijos
        generos_hoja = [g for g in generos if es_hoja(g["id"], generos)]
        print(f"Géneros hoja identificados: {generos_hoja}")  # Depuración

        # Lista final de nombres de géneros sin guiones ni espacios adicionales
        self.genero_lista = [g["nombre"].strip('- ').strip() for g in generos_hoja]
        print(f"Lista final de géneros para el usuario: {self.genero_lista}")  # Depuración

    def crear_label(self, parent, texto, rel_y):
        """Crea un label en una posición relativa."""
        label = tk.Label(parent, text=texto, font="-family {Segoe UI} -size 9",
                        background="#9b0a64", foreground="#ffffff")
        label.place(relx=0.198, rely=rel_y, height=21, width=64)

    def crear_entry(self, parent, rel_y):
        """Crea un campo de texto en una posición relativa."""
        entry = ttk.Entry(parent, font="-family {Segoe UI} -size 9")
        entry.place(relx=0.37, rely=rel_y, relheight=0.057, relwidth=0.331)
        return entry

    def crear_autocomplete_entry(self, parent, rel_y, values):
        """Crea un AutocompleteEntry interactivo."""
        entry = AutocompleteEntry(parent, values, font="-family {Segoe UI} -size 9")
        entry.place(relx=0.37, rely=rel_y, relheight=0.057, relwidth=0.338)
        return entry

    def regresar(self):
        """Lógica para el botón Regresar."""
        print("Botón 'Regresar' presionado.")
        # Cerrar la ventana actual
        self.top.destroy()
        # Importar y llamar al método principal de navegacion.py
        import navegacion
        navegacion.start_up()


    def validacionCampos(self, titulo, autor, genero, editorial, anio, isbn):
        # Validar que los campos no estén vacíos
        if not titulo or not autor or not genero or not editorial or not anio or not isbn:
            messagebox.showwarning("Campos incompletos", "Por favor, completa todos los campos antes de continuar.")
            print("Por favor, completa todos los campos.")
            return False

        # Validar espacios en blanco excesivos
        for campo, valor in [("Título", titulo), ("Autor", autor), ("Género", genero), ("Editorial", editorial), ("Año", anio), ("ISBN", isbn)]:
            if valor.strip() != valor or not valor.strip():
                messagebox.showerror("Texto no válido", f"El campo '{campo}' no debe contener solo espacios ni empezar/terminar con espacios.")
                return False

        
        # Definir patrón de caracteres válidos (letras, números, espacios, guiones, apóstrofes, comas y puntos)
        valid_pattern = re.compile(r"^[a-zA-Z0-9\s\-',.]+$")
        for campo, valor in [("Título", titulo), ("Autor", autor), ("Género", genero), ("Editorial", editorial)]:
            if not valid_pattern.match(valor):
                messagebox.showerror("Caracteres no válidos", f"El campo '{campo}' contiene caracteres especiales no permitidos.")
                return False
        
        # Verificar duplicados del ISBN
        libros_path = os.path.join(self.base_path, "books.json")
        try:
            with open(libros_path, 'r', encoding='utf-8') as f:
                libros = json.load(f)

            # Normalizar el ISBN ingresado (remover guiones)
            isbn_normalizado = isbn.replace("-", "").strip()

            # Verificar si algún ISBN en la base de datos coincide tras normalización
            if any(libro["isbn"].replace("-", "").strip() == isbn_normalizado for libro in libros):
                messagebox.showerror("ISBN duplicado", "El ISBN ya está registrado en el sistema.")
                return False
        except FileNotFoundError:
            print("Archivo 'books.json' no encontrado, se continuará sin verificar duplicados.")
        except json.JSONDecodeError:
            print("Archivo 'books.json' corrupto o vacío, se continuará sin verificar duplicados.")

        

        # Validar que el año sea numérico, no negativo y dentro de un rango razonable
        try:
            anio_int = int(anio)
            anio_actual = datetime.now().year
            if anio_int < 0 or anio_int > anio_actual:
                messagebox.showerror("Año no válido", f"El año debe ser un número positivo y no puede superar el actual ({anio_actual}).")
                return False
        except ValueError:
            messagebox.showerror("Año no válido", "El año debe ser un número entero.")
            return False
        

        # Si todas las validaciones pasan
        return True



    def agregar(self):
        """Lógica para el botón Agregar."""
        # Obtener los valores de los campos
        titulo = self.titulo_entry.get().strip()
        autor = self.autor_combo.get().strip()
        genero = self.genero_combo.get().strip().replace('-', '').strip()
        editorial = self.editorial_combo.get().strip()
        anio = self.anio_entry.get().strip()
        isbn = self.isbn_entry.get().strip()
        print(f"Título: {titulo}, Autor: {autor}, Género: {genero}, Editorial: {editorial}, Año: {anio}, ISBN: {isbn}")

        # Validar los campos
        camposValidos = self.validacionCampos(titulo, autor, genero, editorial, anio, isbn)
        if not camposValidos:
            return

        # Inicializar variables para IDs
        autor_id = None
        genero_id = None
        editorial_id = None

        try:
            # Buscar el ID del autor
            autores_path = os.path.join(self.base_path,"autores.json")
            with open(autores_path, 'r', encoding='utf-8') as f:
                autores = json.load(f)
            print(f"Autores cargados: {[a['nombre'] for a in autores]}")  # Depuración
            autor_lower = autor.lower()
            autor_id = next((a["id"] for a in autores if a["nombre"].lower() == autor_lower), None)
            print(f"Autor ID encontrado: {autor_id}")  # Depuración

            # Buscar el ID del género
            generos_path = os.path.join(self.base_path, "generos.json")
            with open(generos_path, 'r', encoding='utf-8') as f:
                generos = json.load(f)
            print(f"Géneros cargados: {[g['nombre'] for g in generos]}")  # Depuración

            genero_lower = genero.lower()
            genero_encontrado = next((g for g in generos if g["nombre"].strip('- ').lower() == genero_lower), None)

            if genero_encontrado:
                genero_id = genero_encontrado["id"]
                # Validar si el género es hoja
                es_hoja = not any(g for g in generos if g.get("generoPadreId") == genero_id)
                if not es_hoja:
                    messagebox.showwarning(
                        "Género no específico",
                        "El género seleccionado no es lo suficientemente específico. Seleccione otro."
                    )
                    return
                print(f"Género ID encontrado: {genero_id}")  # Depuración
            else:
                print("Género no encontrado.")  # Depuración
                genero_id = None
            

            # Buscar el ID de la editorial
            editoriales_path = os.path.join(self.base_path, "editoriales.json")
            with open(editoriales_path, 'r', encoding='utf-8') as f:
                editoriales = json.load(f)
            print(f"Editoriales cargadas: {[e['nombre'] for e in editoriales]}")  # Depuración
            editorial_lower = editorial.lower()
            editorial_id = next((e["id"] for e in editoriales if e["nombre"].lower() == editorial_lower), None)
            print(f"Editorial ID encontrado: {editorial_id}")  # Depuración

            # Identificar qué entidades faltan
            missing_autor = autor if autor_id is None else None
            missing_genero = genero if genero_id is None else None
            missing_editorial = editorial if editorial_id is None else None

            # Si hay entidades faltantes, confirmar creación
            if missing_autor or missing_genero or missing_editorial:
                confirmacion = self.confirmarNuevos(missing_autor, missing_genero, missing_editorial)
                if not confirmacion:
                    print("Creación de nuevos elementos cancelada por el usuario.")
                    return
                
                # Llamar al método crearNuevos con los nombres faltantes
                nuevos_autor_id, nuevos_genero_id, nuevos_editorial_id = self.crearNuevos(missing_autor, missing_genero, missing_editorial)

                # Reasignar los IDs si se crearon nuevos
                if missing_autor:
                    autor_id = nuevos_autor_id
                if missing_genero:
                    genero_id = nuevos_genero_id
                if missing_editorial:
                    editorial_id = nuevos_editorial_id

            # Verificar que todos los IDs fueron encontrados
            if not all([autor_id, genero_id, editorial_id]):
                print("Error: No se encontraron uno o más IDs requeridos.")
                messagebox.showerror("Error de ID", "No se pudieron obtener todos los IDs requeridos para crear el libro.")
                return

        except FileNotFoundError as e:
            print(f"Archivo no encontrado: {e}")
            messagebox.showerror("Archivo no encontrado", f"Archivo no encontrado: {e}")
            return
        except json.JSONDecodeError as e:
            print(f"Error al decodificar JSON: {e}")
            messagebox.showerror("Error de JSON", f"Error al decodificar JSON: {e}")
            return
        except StopIteration:
            print("Error: No se encontró uno de los valores requeridos.")
            messagebox.showerror("Error de iteración", "No se encontró uno de los valores requeridos.")
            return
        except Exception as e:
            print(f"Error inesperado: {e}")
            messagebox.showerror("Error inesperado", f"Error inesperado: {e}")
            return

        # Generar UUID para el libro
        libro_id = str(uuid.uuid4())

        # Validar que el año sea un número entero
        try:
            anio_int = int(anio)
        except ValueError:
            messagebox.showerror("Año no válido", "El año debe ser un número entero.")
            return

        # Crear el diccionario del libro con los IDs
        libro = {
            "id": libro_id,
            "titulo": titulo,
            "autorId": autor_id,
            "generoId": genero_id,
            "anio_publicacion": anio_int,
            "editorialId": editorial_id,
            "isbn": isbn
        }
        print(f"Libro a agregar: {libro}")  # Depuración

        # Guardar en books.json
        try:
            books_path = os.path.join(self.base_path,"books.json")
            if not os.path.exists(books_path):
                with open(books_path, 'w', encoding='utf-8') as f:
                    json.dump([], f, ensure_ascii=False, indent=4)
                print("Creado archivo books.json vacío.")  # Depuración

            with open(books_path, 'r+', encoding='utf-8') as f:
                try:
                    books = json.load(f)
                except json.JSONDecodeError:
                    books = []
                books.append(libro)
                f.seek(0)
                json.dump(books, f, ensure_ascii=False, indent=4)
                f.truncate()  # Asegurar que se eliminen datos sobrantes
            print(f"Libro agregado a {books_path}")  # Depuración

        except Exception as e:
            print(f"Error al guardar el libro: {e}")
            messagebox.showerror("Error al guardar", f"Error al guardar el libro: {e}")
            return

        # Ejecutar los scripts de persistencia
        try:
            # Definir la ruta absoluta a la carpeta de scripts
            scripts_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', 'arboles_persistencia'))
            scripts = ['guardar_bal.py', 'guardar_nary.py', 'guardar_bin.py', 'guardar_grafo.py']
            for script in scripts:
                script_path = os.path.join(scripts_dir, script)
                if not os.path.exists(script_path):
                    print(f"Script '{script}' no encontrado en '{scripts_dir}'.")
                    continue
                # Ejecutar el script
                print(f"Ejecutando script: {script_path}")  # Depuración
                subprocess.run(['python', script_path], check=True)
            print("Scripts de persistencia ejecutados correctamente.")  # Depuración
        except subprocess.CalledProcessError as e:
            print(f"Error al ejecutar el script {script}: {e}")
            messagebox.showerror("Error en scripts", f"Error al ejecutar el script {script}: {e}")
            return
        except Exception as e:
            print(f"Error al ejecutar los scripts: {e}")
            messagebox.showerror("Error en scripts", f"Error al ejecutar los scripts: {e}")
            return

        print("Libro agregado exitosamente.")
        messagebox.showinfo("Éxito", "Libro agregado exitosamente.")

        # Limpiar los campos después de agregar
        self.titulo_entry.delete(0, tk.END)
        self.autor_combo.var.set('')
        self.genero_combo.var.set('')
        self.editorial_combo.var.set('')
        self.anio_entry.delete(0, tk.END)
        self.isbn_entry.delete(0, tk.END)


    def confirmarNuevos(self, autor, genero, editorial):
        # Confirmar autor
        if autor is not None:
            respuesta_autor = messagebox.askyesno("Confirmar nuevo autor", f"¿Está seguro que desea crear el autor '{autor}'?")
            if not respuesta_autor:
                return False  # Detener si el usuario selecciona "No"

        # Confirmar género
        if genero is not None:
            respuesta_genero = messagebox.askyesno("Confirmar nuevo género", f"¿Está seguro que desea crear el género '{genero}'?")
            if not respuesta_genero:
                return False  # Detener si el usuario selecciona "No"

        # Confirmar editorial
        if editorial is not None:
            respuesta_editorial = messagebox.askyesno("Confirmar nueva editorial", f"¿Está seguro que desea crear la editorial '{editorial}'?")
            if not respuesta_editorial:
                return False  # Detener si el usuario selecciona "No"

        # Si todas las confirmaciones fueron aceptadas
        return True


    def crearNuevos(self, autor, genero, editorial):
        nuevos_autor_id = None
        nuevos_genero_id = None
        nuevos_editorial_id = None

        # Crear nuevo autor si es necesario
        if autor is not None:
            autores_path = os.path.join(self.base_path, "autores.json")
            with open(autores_path, 'r+', encoding='utf-8') as f:
                autores = json.load(f)
                # Encontrar el ID más alto
                max_id = max(a['id'] for a in autores)
                nuevos_autor_id = max_id + 1
                # Crear nuevo autor
                nuevo_autor = {
                    "id": nuevos_autor_id,
                    "nombre": autor
                }
                autores.append(nuevo_autor)
                # Escribir de vuelta en el archivo
                f.seek(0)
                json.dump(autores, f, ensure_ascii=False, indent=4)
                f.truncate()

        # Crear nueva editorial si es necesario
        if editorial is not None:
            editoriales_path = os.path.join(self.base_path, "editoriales.json")
            with open(editoriales_path, 'r+', encoding='utf-8') as f:
                editoriales = json.load(f)
                # Encontrar el ID más alto
                max_id = max(e['id'] for e in editoriales)
                nuevos_editorial_id = max_id + 1
                # Crear nueva editorial
                nueva_editorial = {
                    "id": nuevos_editorial_id,
                    "nombre": editorial
                }
                editoriales.append(nueva_editorial)
                # Escribir de vuelta en el archivo
                f.seek(0)
                json.dump(editoriales, f, ensure_ascii=False, indent=4)
                f.truncate()

        # Crear nuevo género si es necesario
        if genero is not None:
            # Obtener lista de géneros
            generos_path = os.path.join(self.base_path, "generos.json")
            with open(generos_path, 'r+', encoding='utf-8') as f:
                generos = json.load(f)
            # Construir lista de nombres de géneros
            genero_nombres = [g['nombre'] for g in generos]
            # Incluir 'Biblioteca' como opción
            genero_nombres.insert(0, 'Biblioteca')

            # Crear ventana emergente para seleccionar el género padre
            def seleccionar_genero_padre():
                genero_padre_window = tk.Toplevel(self.top)
                genero_padre_window.title("Seleccionar género padre")
                genero_padre_window.geometry("300x100")

                tk.Label(genero_padre_window, text="Seleccione el género padre:").pack(pady=5)
                genero_var = tk.StringVar()
                genero_combobox = ttk.Combobox(genero_padre_window, textvariable=genero_var, values=genero_nombres, state='readonly')
                genero_combobox.pack(pady=5)
                genero_combobox.current(0)

                def confirmar():
                    genero_padre_window.destroy()

                tk.Button(genero_padre_window, text="Aceptar", command=confirmar).pack(pady=5)
                genero_padre_window.grab_set()
                self.top.wait_window(genero_padre_window)
                return genero_var.get()

            parent_genero_nombre = seleccionar_genero_padre()
            if not parent_genero_nombre:
                messagebox.showerror("Error", "Debe seleccionar un género padre.")
                return None, None, None

            # Obtener el ID del género padre seleccionado
            if parent_genero_nombre == 'Biblioteca':
                genero_padre_id = None  # O usar un ID especial si 'Biblioteca' es la raíz
            else:
                genero_padre = next((g for g in generos if g['nombre'] == parent_genero_nombre), None)
                if genero_padre is not None:
                    genero_padre_id = genero_padre['id']
                else:
                    messagebox.showerror("Error", "Género padre seleccionado no válido.")
                    return None, None, None

            # Encontrar el ID más alto
            max_id = max(g['id'] for g in generos)
            nuevos_genero_id = max_id + 1
            # Crear nuevo género
            nuevo_genero = {
                "id": nuevos_genero_id,
                "nombre": genero,
                "generoPadreId": genero_padre_id
            }
            generos.append(nuevo_genero)
            # Escribir de vuelta en el archivo
            with open(generos_path, 'w', encoding='utf-8') as f:
                json.dump(generos, f, ensure_ascii=False, indent=4)

        return nuevos_autor_id, nuevos_genero_id, nuevos_editorial_id



# Para ejecutar la ventana de prueba
if __name__ == "__main__":
    root = tk.Tk()
    _style_code()
    app = Toplevel1(top=root)
    root.mainloop()
